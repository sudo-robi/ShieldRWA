import {
  sha2563 as sha2562,
  toHex
} from "./chunk-TKWG7ZNV.js";
import {
  concat2 as concat,
  fromBytes2 as fromBytes,
  fromHex2 as fromHex,
  fromString
} from "./chunk-5O4HPFBN.js";
import {
  Field,
  createCurve,
  createHasher,
  mapToCurveSimpleSWU,
  sha256,
  sha384,
  sha512
} from "./chunk-QA6X5G6A.js";

// node_modules/@noble/curves/esm/nist.js
var Fp256 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var p256_a = Fp256.create(BigInt("-3"));
var p256_b = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p256 = createCurve({
  a: p256_a,
  b: p256_b,
  Fp: Fp256,
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha256);
var secp256r1 = p256;
var p256_mapSWU = (() => mapToCurveSimpleSWU(Fp256, {
  A: p256_a,
  B: p256_b,
  Z: Fp256.create(BigInt("-10"))
}))();
var p256_hasher = (() => createHasher(secp256r1.ProjectivePoint, (scalars) => p256_mapSWU(scalars[0]), {
  DST: "P256_XMD:SHA-256_SSWU_RO_",
  encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
  p: Fp256.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var Fp384 = Field(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"));
var p384_a = Fp384.create(BigInt("-3"));
var p384_b = BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");
var p384 = createCurve({
  a: p384_a,
  b: p384_b,
  Fp: Fp384,
  n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
  Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
  Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),
  h: BigInt(1),
  lowS: false
}, sha384);
var secp384r1 = p384;
var p384_mapSWU = (() => mapToCurveSimpleSWU(Fp384, {
  A: p384_a,
  B: p384_b,
  Z: Fp384.create(BigInt("-12"))
}))();
var p384_hasher = (() => createHasher(secp384r1.ProjectivePoint, (scalars) => p384_mapSWU(scalars[0]), {
  DST: "P384_XMD:SHA-384_SSWU_RO_",
  encodeDST: "P384_XMD:SHA-384_SSWU_NU_",
  p: Fp384.ORDER,
  m: 1,
  k: 192,
  expand: "xmd",
  hash: sha384
}))();
var Fp521 = Field(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
var p521_a = Fp521.create(BigInt("-3"));
var p521_b = BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");
var p521 = createCurve({
  a: p521_a,
  b: p521_b,
  Fp: Fp521,
  n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
  Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
  Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),
  h: BigInt(1),
  lowS: false,
  allowedPrivateKeyLengths: [130, 131, 132]
  // P521 keys are variable-length. Normalize to 132b
}, sha512);
var secp521r1 = p521;
var p521_mapSWU = (() => mapToCurveSimpleSWU(Fp521, {
  A: p521_a,
  B: p521_b,
  Z: Fp521.create(BigInt("-4"))
}))();
var p521_hasher = (() => createHasher(secp521r1.ProjectivePoint, (scalars) => p521_mapSWU(scalars[0]), {
  DST: "P521_XMD:SHA-512_SSWU_RO_",
  encodeDST: "P521_XMD:SHA-512_SSWU_NU_",
  p: Fp521.ORDER,
  m: 1,
  k: 256,
  expand: "xmd",
  hash: sha512
}))();

// node_modules/@noble/curves/esm/p256.js
var p2562 = p256;
var secp256r12 = p256;
var hashToCurve = (() => p256_hasher.hashToCurve)();
var encodeToCurve = (() => p256_hasher.encodeToCurve)();

// node_modules/ox/_esm/core/P256.js
function verify(options) {
  const { hash, payload, publicKey, signature } = options;
  return secp256r12.verify(signature, payload instanceof Uint8Array ? payload : fromHex(payload), toHex(publicKey).substring(2), ...hash ? [{ prehash: true, lowS: true }] : []);
}

// node_modules/ox/_esm/core/Base64.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var integerToCharacter = Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a, i) => [i, a.charCodeAt(0)]));
var characterToInteger = {
  ...Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a, i) => [a.charCodeAt(0), i])),
  ["=".charCodeAt(0)]: 0,
  ["-".charCodeAt(0)]: 62,
  ["_".charCodeAt(0)]: 63
};
function toBytes(value) {
  const base64 = value.replace(/=+$/, "");
  const size = base64.length;
  const decoded = new Uint8Array(size + 3);
  encoder.encodeInto(base64 + "===", decoded);
  for (let i = 0, j = 0; i < base64.length; i += 4, j += 3) {
    const x = (characterToInteger[decoded[i]] << 18) + (characterToInteger[decoded[i + 1]] << 12) + (characterToInteger[decoded[i + 2]] << 6) + characterToInteger[decoded[i + 3]];
    decoded[j] = x >> 16;
    decoded[j + 1] = x >> 8 & 255;
    decoded[j + 2] = x & 255;
  }
  const decodedSize = (size >> 2) * 3 + (size % 4 && size % 4 - 1);
  return new Uint8Array(decoded.buffer, 0, decodedSize);
}

// node_modules/ox/_esm/core/WebAuthnP256.js
var createChallenge = Uint8Array.from([
  105,
  171,
  180,
  181,
  160,
  222,
  75,
  198,
  42,
  42,
  32,
  31,
  141,
  37,
  186,
  233
]);
function verify2(options) {
  const { challenge, hash = true, metadata, publicKey, signature } = options;
  const { authenticatorData, challengeIndex, clientDataJSON, typeIndex, userVerificationRequired } = metadata;
  const authenticatorDataBytes = fromHex(authenticatorData);
  if (authenticatorDataBytes.length < 37)
    return false;
  const flag = authenticatorDataBytes[32];
  if ((flag & 1) !== 1)
    return false;
  if (userVerificationRequired && (flag & 4) !== 4)
    return false;
  if ((flag & 8) !== 8 && (flag & 16) === 16)
    return false;
  if (typeIndex !== void 0) {
    const type = '"type":"webauthn.get"';
    if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1))
      return false;
  }
  const challengeMatch = challengeIndex !== void 0 ? clientDataJSON.slice(Number(challengeIndex)).match(/^"challenge":"(.*?)"/) : clientDataJSON.match(/"challenge":"(.*?)"/);
  if (!challengeMatch)
    return false;
  const [_, challenge_extracted] = challengeMatch;
  if (fromBytes(toBytes(challenge_extracted)) !== challenge)
    return false;
  const clientDataJSONHash = sha2562(fromString(clientDataJSON), {
    as: "Bytes"
  });
  const payload = concat(authenticatorDataBytes, clientDataJSONHash);
  return verify({
    hash,
    payload,
    publicKey,
    signature
  });
}

// node_modules/ox/_esm/core/TransactionReceipt.js
var fromRpcType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
var toRpcType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};

export {
  p2562 as p256,
  secp256r12 as secp256r1,
  verify,
  verify2,
  fromRpcType,
  toRpcType
};
//# sourceMappingURL=chunk-AEHH72WA.js.map
